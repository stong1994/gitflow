use crossterm::event::{read, Event, KeyCode};
use crossterm::execute;
use crossterm::style::{Color, Print, ResetColor, SetBackgroundColor, SetForegroundColor, Stylize};
use crossterm::terminal::disable_raw_mode;
use crossterm::{event::poll, terminal::enable_raw_mode};
use lazy_static::lazy_static;
use serde_json::from_str;
use std::io::{stdout, BufRead, BufReader, Write};
use std::process::{Command, Output, Stdio};
use std::str::FromStr;
use std::thread::sleep;
use std::time::Duration;
use std::{env, io, process};

fn main() {
    check_git_installed();
    check_in_git_repo();

    if !has_file_added() {
        add_files();
    }
    if has_uncommitted_changes() {
        commit();
    }
    push();
}

fn has_file_added() -> bool {
    let output = Command::new("git")
        .arg("diff")
        .arg("--cached")
        .output()
        .expect("git diff failed");

    !output.stdout.is_empty()
}

fn add_files() {
    if !any_changes() {
        return;
    }

    UserPrompt::new("==> There are files ready to be added.".to_string())
        .add_option("Y".to_string(), "Add all files".to_string())
        .print();

    loop {
        enable_raw_input();
        if let Ok(Event::Key(event)) = read() {
            match event.code {
                KeyCode::Char('y') => {
                    git_add(true);
                    break;
                }
                KeyCode::Char('q') => quit(),
                _ => {
                    output_invalid_type();
                }
            }
        }
    }
}

fn commit() {
    UserPrompt::new("==> There are uncommitted changes.".to_string())
        .add_option("Y".to_string(), "Commit with AICommit".to_string())
        .add_option("M".to_string(), "Enter commit message manually".to_string())
        .print();

    loop {
        enable_raw_input();
        if let Ok(Event::Key(event)) = read() {
            match event.code {
                KeyCode::Char('y') => {
                    aicommit();
                    break;
                }
                KeyCode::Char('m') => {
                    disable_raw_input();
                    println!("Please input commit message:");

                    let mut commit_message = String::new();
                    io::stdin()
                        .read_line(&mut commit_message)
                        .expect("Failed to read line");

                    commit_files(&commit_message);

                    break;
                }
                KeyCode::Char('q') => quit(),
                _ => output_invalid_type(),
            }
        }
    }
}

fn push() {
    let remote = get_remote_name();
    let branch = get_branch_name();
    git_push(&remote, &branch);
}

fn get_remote_name() -> String {
    let remotes = get_remote_names();
    if remotes.is_empty() {
        disable_raw_input();
        println!("Please input the remote name");
        let mut remote = String::new();
        io::stdin()
            .read_line(&mut remote)
            .expect("Failed to read line");
        println!("Please input the url of {}.", remote);
        let mut url = String::new();
        io::stdin()
            .read_line(&mut url)
            .expect("Failed to read line");

        git_set_remote(&remote, &url);
        remote
    } else if remotes.len() == 1 {
        UserPrompt::new("==> There is only one remote repository.".to_string())
            .add_option("Y".to_string(), "Push to the remote".to_string())
            .print();
        loop {
            enable_raw_input();
            if let Event::Key(event) = read().unwrap() {
                match event.code {
                    KeyCode::Char('y') => {
                        return remotes[0].clone();
                    }
                    KeyCode::Char('q') => quit(),
                    _ => output_invalid_type(),
                }
            }
        }
    } else {
        let mut prompt = UserPrompt::new("==> There are multiple remote:".to_string());
        remotes.iter().enumerate().for_each(|(i, remote)| {
            prompt.add_option(i.to_string(), remote.to_string());
        });

        loop {
            enable_raw_input();
            if let Event::Key(event) = read().unwrap() {
                match event.code {
                    KeyCode::Char(c) => {
                        let i = (c as u8 - b'0') as usize;
                        if i > 0 && i <= remotes.len() {
                            return remotes[i - 1].clone();
                        } else {
                            disable_raw_input();
                            println!("Invalid input. Please try again.");
                        }
                    }
                    _ => {
                        disable_raw_input();
                        println!("Invalid input. Please try again.");
                    }
                }
            }
        }
    }
}

fn check_git_installed() {
    if !check_command_installed("git") {
        report_error("Git is not installed. Please install git first.");
    }
}

fn check_aicommit_installed() {
    if !check_command_installed("aicommit") {
        report_error("AICommit is not installed. Please install aicommit first. see: https://github.com/stong1994/aicommit");
    }
}

fn check_command_installed(command: &str) -> bool {
    let os = env::consts::OS;
    let exec = if os == "windows" { "where" } else { "which" };
    let output = Command::new(exec)
        .arg(command)
        .output()
        .expect("failed to execute process");
    !output.stdout.is_empty()
}

fn check_in_git_repo() {
    let output = Command::new("git")
        .arg("rev-parse")
        .arg("--is-inside-work-tree")
        .output()
        .expect("git rev-parse failed");
    if output.stdout != b"true\n" {
        report_error("Not in a git repository.");
    }
}

fn report_error(msg: &str) {
    disable_raw_input();
    println!("{}", msg);
    process::exit(1);
}

fn quit() {
    disable_raw_input();
    println!("quiting...");
    process::exit(0);
}

fn git_add(all: bool) {
    let command = &mut Command::new("git");
    let mut c = command.arg("add");
    if all {
        c = c.arg("--all")
    }
    c.output().expect("git add failed");
    output_success_result("All files have been added.");
}

fn commit_files(msg: &str) {
    Command::new("git")
        .arg("commit")
        .arg("-m")
        .arg(msg)
        .spawn()
        .expect("Failed to commit");
}

fn aicommit() {
    check_aicommit_installed();
    disable_raw_input(); // must disable raw mode, otherwise follow output will mess up the terminal
    println!("\n==> generating command by aicommit:\nwaiting....");
    let command = execute_aicommit();
    UserPrompt::new("==> AICommit generated command".to_string())
        .add_option("Y".to_string(), "Execute the command".to_string())
        .add_option("R".to_string(), "Regenerate command".to_string())
        .add_option("M".to_string(), "Enter commit message manually".to_string())
        .print();

    loop {
        enable_raw_input();
        if poll(std::time::Duration::from_millis(100)).unwrap() {
            if let Event::Key(event) = read().unwrap() {
                match event.code {
                    KeyCode::Char('y') => {
                        execute_commit_command(&command);
                        break;
                    }
                    KeyCode::Char('r') => {
                        aicommit();
                        break;
                    }
                    KeyCode::Char('m') => {
                        disable_raw_input();
                        println!("Please input commit message:");

                        let mut commit_message = String::new();
                        io::stdin()
                            .read_line(&mut commit_message)
                            .expect("Failed to read line");

                        commit_files(&commit_message);

                        break;
                    }
                    KeyCode::Char('q') => quit(),
                    _ => output_invalid_type(),
                }
            }
        }
    }
}
fn any_changes() -> bool {
    let output = Command::new("git")
        .arg("status")
        .arg("--porcelain")
        .output()
        .expect("git status failed");
    !output.stdout.is_empty()
}
fn has_uncommitted_changes() -> bool {
    let output = Command::new("git")
        .arg("diff")
        .arg("--cached")
        .arg("--exit-code")
        .output() // can't use status() directly as it will output the git repsponse
        .expect("Failed to execute git command");

    !output.status.success()
}

fn get_remote_names() -> Vec<String> {
    let output = Command::new("git")
        .arg("remote")
        .output()
        .expect("Failed to execute git command");

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        report_error(&format!("Failed to get remote names: {}", stderr));
    }
    let stdout = String::from_utf8_lossy(&output.stdout);
    stdout.split_whitespace().map(String::from).collect()
}

fn get_branch_name() -> String {
    let local_branch = get_current_branch();

    UserPrompt::new("==> Please choose an branch".to_string())
        .add_option("Y".to_string(), local_branch.clone())
        .add_option("M".to_string(), "Input branch manually.".to_string())
        .print();

    enable_raw_input();
    loop {
        if let Ok(Event::Key(event)) = read() {
            match event.code {
                KeyCode::Char('y') => {
                    return local_branch;
                }
                KeyCode::Char('m') => {
                    disable_raw_input();

                    let mut branch = String::new();
                    io::stdin()
                        .read_line(&mut branch)
                        .expect("Failed to read line");
                    return branch;
                }
                _ => output_invalid_type(),
            }
        }
    }
}
fn get_current_branch() -> String {
    let output = Command::new("git")
        .arg("rev-parse")
        .arg("--abbrev-ref")
        .arg("HEAD")
        .output()
        .expect("Failed to execute git command");
    if !output.status.success() {
        disable_raw_input();
        let stderr = String::from_utf8_lossy(&output.stderr);
        report_error(&format!("Failed to get current branch: {}", stderr));
    }
    let stdout = String::from_utf8_lossy(&output.stdout);
    stdout.trim().to_string()
}

fn git_set_remote(name: &str, url: &str) {
    disable_raw_input();
    let output = Command::new("git")
        .arg("remote")
        .arg("add")
        .arg(name)
        .arg(url)
        .output()
        .expect("Failed to execute git push");
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        report_error(&format!("Failed to add remote: {}", stderr));
    }
    println!("Set remote {} successfully.", name);
}

fn git_push(remote: &str, branch: &str) {
    let output = Command::new("git")
        .arg("push")
        .arg(remote)
        .arg(branch)
        .output()
        .expect("Failed to execute git push");
    if output.status.success() {
        disable_raw_input();
        println!("Pushed to {} successfully.", remote);
    } else {
        disable_raw_input();
        let stderr = String::from_utf8_lossy(&output.stderr);
        report_error(&format!("Failed to push: {}", stderr));
    }
}

fn execute_aicommit() -> String {
    disable_raw_input();
    println!("{:-^30}", "AICOMMIT BEGIN");
    let mut child = Command::new("aicommit")
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to execute aicommit");

    let stdout = child.stdout.take().expect("Failed to capture stdout");
    let reader = BufReader::new(stdout);

    let mut console = io::stdout();
    let mut full_output = String::new();

    for word in reader.split(b' ') {
        let mut word = word.expect("Failed to read word");
        word.push(b' ');
        console
            .write_all(&word)
            .expect("Failed to write to console");
        console.flush().expect("Failed to flush console");
        full_output.push_str(&String::from_utf8(word).expect("Failed to convert word to string"));
        sleep(Duration::from_millis(300));
    }
    console
        .write_all(b"\n")
        .expect("Failed to write to console");
    console.flush().expect("Failed to flush console");

    println!("{:-^30}", "AICOMMIT END");
    let output = child.wait().expect("Failed to wait on child");

    if !output.success() {
        report_error("aicommit execution failed.");
    }
    full_output
}

fn execute_commit_command(command: &str) {
    disable_raw_input();
    let output = execute_command(command);
    if output.status.success() {
        let stdout = String::from_utf8_lossy(&output.stdout);
        println!("\nCommand executed successfully. Output:\n{}", stdout);
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        report_error(&format!("Command execution failed: {}.", stderr));
    }
}

fn execute_command(command: &str) -> Output {
    disable_raw_input();
    println!("Executing: \n\t {}", command.green().bold());
    Command::new("sh")
        .arg("-c")
        .arg(command)
        .output()
        .expect("Failed to execute command")
}
fn enable_raw_input() {
    enable_raw_mode().expect("Failed to enable raw mode");
}

fn disable_raw_input() {
    disable_raw_mode().expect("Failed to disable raw mode");
}

fn output_success_result(result: &str) {
    disable_raw_input();
    println!("{}", result.yellow());
}

struct UserPrompt {
    prompt: String,
    options: Vec<[String; 2]>,
}
lazy_static! {
    static ref PROMPT_BG_COLOR: crossterm::style::Color = hex_to_color("#254336");
    static ref PROMPT_FG_COLOR: crossterm::style::Color = hex_to_color("#ECB159");
    static ref PROMPT_OPTIONI_KEY_FG_COLOR: crossterm::style::Color = hex_to_color("#FFA62F");
}
impl UserPrompt {
    fn new(prompt: String) -> Self {
        UserPrompt {
            prompt,
            options: Vec::new(),
        }
    }

    fn add_option(&mut self, key: String, desc: String) -> &mut UserPrompt {
        self.options.push([key, desc]);
        self
    }

    fn print(&self) {
        colorful_print(
            *PROMPT_BG_COLOR,
            *PROMPT_FG_COLOR,
            format!("\n{}\n\nPlease choose an option:\n", self.prompt.clone()),
        );
        // println!(
        //     "\n{}:\nPlease choose an option:",
        //     self.prompt.clone().blue()
        // );

        self.options.clone().into_iter().for_each(|option| {
            colorful_print(
                Color::Green,
                Color::DarkBlue,
                format!("\n\t- [{}]: ", option[0].clone()),
            );
        });
        self.options.clone().into_iter().for_each(|option| {
            colorful_print(Color::Green, Color::DarkBlue, option[1].clone() + "\n");
        });
        colorful_print(Color::Green, Color::DarkBlue, "\n\t- [Q]: ".to_string());
        colorful_print(Color::Green, Color::DarkBlue, "Quit\n".to_string());
    }
}

fn output_invalid_type() {
    colorful_print(
        Color::DarkRed,
        Color::White,
        "Invalid input. Please try again.\n".to_string(),
    );
}

fn colorful_print(bg: Color, fg: Color, content: String) {
    disable_raw_input();
    execute!(
        stdout(),
        SetForegroundColor(fg),
        SetBackgroundColor(bg),
        Print(content),
        ResetColor
    )
    .expect("Failed to colorful print");
}

fn hex_to_color(hex: &str) -> crossterm::style::Color {
    let r = u8::from_str_radix(&hex[1..3], 16).unwrap();
    let g = u8::from_str_radix(&hex[3..5], 16).unwrap();
    let b = u8::from_str_radix(&hex[5..7], 16).unwrap();

    crossterm::style::Color::Rgb { r, g, b }
}
